% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/OptimizerMies.R
\name{OptimizerMies}
\alias{OptimizerMies}
\title{Mixed Integer Evolutionary Strategies Optimizer}
\description{
Perform optimization using evolutionary strategies. \code{OptimizerMies} and \code{TunerMies} implement a standard ES optimization
algorithm, performing initialization first, followed by a loop of performance evaluation, survival selection, parent selection, mutation, and
recombination. Currently two different survival modes ("comma" and "plus") are supported. Multi-fidelity optimization, similar
to the "rolling-tide" algorithm described in Fieldsend (2014). The modular design and reliance on
\code{\link{MiesOperator}} objects to perform central parts of the optimization algorithm makes this \code{\link[bbotk:Optimizer]{Optimizer}}
highly flexible and configurable. In combination with \code{\link{OperatorCombination}} mutators and recombinators, an algorithm
as presented in Li (2013) can easily be implemented.

\code{OptimizerMies} implements a standard evolutionary strategies loop:
\enumerate{
\item Prime operators, using \code{mies_prime_operators()}
\item Initialize population, using \code{mies_init_population()}
\item Optionally, evaluate survivors with higher fidelity if the multi-fidelity functionality is being used
\item Generate offspring by selecting parents, recombining and mutating them, using \code{mies_generate_offspring()}
\item Evaluate performance, using \code{mies_evaluate_offspring()}
\item Select survivors, using either \code{mies_survival_plus()} or \code{mies_survival_comma()}, depending on the \code{survival_strategy} hyperparameter
\item Jump to 3.
}
}
\section{Terminating}{

As with all optimizers, \code{\link[bbotk:Terminator]{Terminator}}s are used to end optimization after a specific number of evaluations were performed,
time elapsed, or other conditions are satisfied. Of particular interest is \code{\link{TerminatorGeneration}}, which terminates after a number
of generations were evaluated in \code{OptimizerMies}. The initial population counts as generation 1, its offspring as generation 2 etc.;
fidelity refinements are always included in their generation, \code{\link{TerminatorGeneration}} avoids terminating right before they are evaluated.
Other terminators may, however, end the optimization process at any time.
}

\section{Multi-Fidelity}{

\code{miesmuschel} provides a simple multi-fidelity optimization mechanism that allows increasing fidelity both by generation
number and survival status. When \code{multi_fidelity} is \code{TRUE}, then one search space component of the \code{\link[bbotk:OptimInstance]{OptimInstance}}
must have the \code{"budget"} tag, which is then optimized as the "budget" component. This means that the value of this component is
determined by the \code{fidelity_schedule} hyperparameter, which must contain a \code{data.frame} with columns \code{"generation"}, \code{"budget_new"} and
\code{"budget_survivors"}. The budget component's value of newly sampled individuals is set to the \code{"budget_new"} entry in the generation's row,
and surviving individuals are evaluated again with the budget set to the \code{"budget_survivors"} value (unless they are the same). At the
end of a generation, if the \code{"budget_survivors"} value changes, all individuals from previous generations are re-evaluated with the
new budget value, unless \code{fidelity_current_gen_only} is set to \code{TRUE} (and unless the budget value decreases and \code{fidelity_monotonic} is \code{TRUE}).
This makes it possible to implement increasing fidelity by generation, and also increasing fidelity for samples that survived a generation.

The \code{fidelity_schedule} hyperparameter's \code{"generation"} column determines which row is currently active. A row becomes active in the
generation that is listed, and becomes inactive whenever a different row becomes active. So e.g. if \code{fidelity_schedule} contains a row
with \code{"generation"} set to 1, and one set to 4, then the first row is active during generations 1, 2, and 3, and the second row
is active for all following generations.
}

\section{Additional Components}{

The search space over which the optimization is performed is fundamentally tied to the \code{\link[bbotk:Objective]{Objective}}, and therefore
to the \code{\link[paradox:OptimInstance]{OptimInstance}} given to \code{OptimizerMies$optimize()}. However, some advanced Evolutionary Strategy based
algorithms may need to make use of additional search space components that are independent of the particular objective. An example is
self-adaption as implemented in \code{\link{OperatorCombination}}, where one or several components can be used to adjust operator behaviour.
These additional components are supplied to the optimizer through the \code{additional_component_sampler} hyperparameter, which takes
a \code{\link[paradox:Sampler]{Sampler}} object. This object both has an associated \code{\link[paradox:ParamSet]{ParamSet}} which represents the
additional components that are present, and it provides a method for generating the initial values of these components. The search space
that is seen by the \code{\link{MiesOperator}}s is then the union of the \code{\link{OptimInstance}}'s \code{\link[paradox:ParamSet]{ParamSet}}, and the
\code{\link[paradox:Sampler]{Sampler}}'s \code{\link[paradox:ParamSet]{ParamSet}}.
}

\section{Hyperparameters}{

\code{OptimizerMies} has the hyperparameters of the \code{mutator}, \code{recombinator}, \code{parent_selector}, \code{survival_selector}, and, if given,
\code{elite_selector} operator given during construction, and prefixed according to the name of the argument (\code{mutator}'s hyperparameters
are prefixed \code{"mutator."} etc.). When using the construction arguments' default values, they are all "proxy" operators: \code{\link{MutatorProxy}},
\code{\link{RecombinatorProxy}} and \code{\link{SelectorProxy}}. This means that the respective hyperparameters become \code{mutator.operation}, \code{recombinator.operation} etc.,
so the operators themselves can be set via hyperparameters in this case.

Further hyperparameters are:
\itemize{
\item \code{lambda} :: \code{integer(1)}\cr
Offspring size: Number of individuals that are created and evaluated anew for each generation. This is equivalent to the
\code{lambda} parameter of \code{\link[=mies_generate_offspring]{mies_generate_offspring()}}, see there for more information. Initialized to 10.
\item \code{mu} :: \code{integer(1)}\cr
Population size: Number of individuals that are sampled in the beginning, and which are selected with each survival step.
This is equivalent to the \code{mu} parameter of \code{\link[=mies_init_population]{mies_init_population()}}, see there for more information. Initialized to 1.
\item \code{survival_strategy} :: \code{character(1)}\cr
May be \code{"plus"}, or, if the \code{elite_selector} construction argument is not \code{NULL}, \code{"comma"}: Choose whether \code{\link[=mies_survival_plus]{mies_survival_plus()}}
or \code{\link[=mies_survival_comma]{mies_survival_comma()}} is used for survival selection. Initialized to \code{"plus"}.
\item \code{n_elite} :: \code{integer(1)}\cr
Only if the \code{elite_selector} construction argument is not \code{NULL}, and only valid when \code{survival_strategy} is \code{"comma"}:
Number of elites, i.e. individuals from the parent generation, to keep during "Comma" survival.
This is equivalent to the \code{n_elite} parameter of \code{\link[=mies_survival_comma]{mies_survival_comma()}}, see there for more information.
\item \code{initializer} :: \code{function}\cr
Function that generates the initial population as a \code{\link[paradox:Design]{Design}} object,
with arguments \code{param_set} and \code{n}, functioning like \code{\link[paradox:generate_design_random]{paradox::generate_design_random}} or \code{\link[paradox:generate_design_lhs]{paradox::generate_design_lhs}}.
This is equivalent to the \code{initializer} parameter of \code{\link[=mies_init_population]{mies_init_population()}}, see there for more information. Initialized to
\code{\link[paradox:generate_design_random]{generate_design_random()}}.
\item \code{additional_component_sampler} :: \code{\link[paradox:Sampler]{Sampler}} | \code{NULL}\cr
Additional components that may be part of individuals as seen by mutation, recombination, and selection \code{\link{MiesOperator}}s, but
that are not part of the search space of the \code{\link[bbotk:OptimInstance]{OptimInstance}} being optimized.
This is equivalent to the \code{additional_component_sampler} parameter of \code{\link[=mies_init_population]{mies_init_population()}}, see there for more information.
Initialized to \code{NULL} (no additional components).
\item \code{fidelity_schedule} :: \code{data.frame}\cr
Only if the \code{multi_fidelity} construction argument is \code{TRUE}:
Table that determines the value of the "budget" component of individuals being evaluated when doing multi-fidelity optimization.
This is equivalent to the \code{fidelity_schedule} parameter of \code{\link[=mies_init_population]{mies_init_population()}}, \code{\link[=mies_evaluate_offspring]{mies_evaluate_offspring()}}, and \code{\link[=mies_step_fidelity]{mies_step_fidelity()}};
see there for more information.\cr
When this hyperparameter is present (i.e. \code{multi_fidelity} is \code{TRUE}), then it is initialized to a \code{data.frame} containing one row
for generation 1, setting budget to 1 for both new and survivor individuals.
\item \code{fidelity_generation_lookahead} :: \code{logical(1)}\cr
Only if the \code{multi_fidelity} construction argument is \code{TRUE}:
Whether to use the \code{"survivor_budget"} of the \emph{next} generation, instead of the \emph{current} generation, when doing fidelity refinement
in \code{\link[=mies_step_fidelity]{mies_step_fidelity()}}.
This is equivalent to the \code{generation_lookahead} parameter of \code{\link[=mies_step_fidelity]{mies_step_fidelity()}}, see there for more information.\cr
When this hyperparameter is present (i.e. \code{multi_fidelity} is \code{TRUE}), then it is initialized to \code{TRUE}.
\item \code{fidelity_current_gen_only} :: \code{logical(1)}\cr
Only if the \code{multi_fidelity} construction argument is \code{TRUE}:
When doing fidelity refinement in \code{\link[=mies_step_fidelity]{mies_step_fidelity()}}, whether to refine all individuals with different budget component,
or only individuals created in the current generation.
This is equivalent to the \code{current_gen_only} parameter of \code{\link[=mies_step_fidelity]{mies_step_fidelity()}}, see there for more information.\cr
When this hyperparameter is present (i.e. \code{multi_fidelity} is \code{TRUE}), then it is initialized to \code{FALSE}.
\item \code{fidelity_monotonic} :: \code{logical(1)}\cr
Only if the \code{multi_fidelity} construction argument is \code{TRUE}:
Whether to only do fidelity refinement in \code{\link[=mies_step_fidelity]{mies_step_fidelity()}} for individuals for which the when budget component value would \emph{increase}.
This is equivalent to the \code{monotonic} parameter of \code{\link[=mies_step_fidelity]{mies_step_fidelity()}}, see there for more information.\cr
When this hyperparameter is present (i.e. \code{multi_fidelity} is \code{TRUE}), then it is initialized to \code{TRUE}.
}
}

\references{
Fieldsend, E J, Everson, M R (2014).
\dQuote{The rolling tide evolutionary algorithm: A multiobjective optimizer for noisy optimization problems.}
\emph{IEEE Transactions on Evolutionary Computation}, \bold{19}(1), 103--117.

Li, Rui, Emmerich, TM M, Eggermont, Jeroen, B"ack, Thomas, Sch"utz, Martin, Dijkstra, Jouke, Reiber, HC J (2013).
\dQuote{Mixed integer evolution strategies for parameter optimization.}
\emph{Evolutionary computation}, \bold{21}(1), 29--64.
}
\section{Super class}{
\code{\link[bbotk:Optimizer]{bbotk::Optimizer}} -> \code{OptimizerMies}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{OptimizerMies$new()}}
\item \href{#method-clone}{\code{OptimizerMies$clone()}}
}
}
\if{html}{
\out{<details open ><summary>Inherited methods</summary>}
\itemize{
\item \out{<span class="pkg-link" data-pkg="bbotk" data-topic="Optimizer" data-id="format">}\href{../../bbotk/html/Optimizer.html#method-format}{\code{bbotk::Optimizer$format()}}\out{</span>}
\item \out{<span class="pkg-link" data-pkg="bbotk" data-topic="Optimizer" data-id="optimize">}\href{../../bbotk/html/Optimizer.html#method-optimize}{\code{bbotk::Optimizer$optimize()}}\out{</span>}
\item \out{<span class="pkg-link" data-pkg="bbotk" data-topic="Optimizer" data-id="print">}\href{../../bbotk/html/Optimizer.html#method-print}{\code{bbotk::Optimizer$print()}}\out{</span>}
}
\out{</details>}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\if{latex}{\out{\hypertarget{method-new}{}}}
\subsection{Method \code{new()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{OptimizerMies$new(
  mutator = MutatorProxy$new(),
  recombinator = RecombinatorProxy$new(),
  parent_selector = SelectorProxy$new(),
  survival_selector = SelectorProxy$new(),
  elite_selector = NULL,
  multi_fidelity = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{mutator}}{(\code{Mutator})\cr
Mutation operation to perform during \code{\link[=mies_generate_offspring]{mies_generate_offspring()}}, see there for more information. Default is \code{\link{MutatorProxy}}, which
exposes the operation as a hyperparameter of the optimizer itself.}

\item{\code{recombinator}}{(\code{Recombinator})\cr
Recombination operation to perform during \code{\link[=mies_generate_offspring]{mies_generate_offspring()}}, see there for more information. Default is \code{\link{RecombinatorProxy}},
which exposes the operation as a hyperparameter of the optimizer itself. Note: The default \code{\link{RecombinatorProxy}} has \verb{$n_indivs_in} set to 2,
so to use recombination operations with more than two inputs, or to use population size of 1, it may be necessary to construct this
argument explicitly.}

\item{\code{parent_selector}}{(\code{Selector})\cr
Parent selection operation to perform during \code{\link[=mies_generate_offspring]{mies_generate_offspring()}}, see there for more information. Default is \code{\link{SelectorProxy}},
which exposes the operation as a hyperparameter of the optimizer itself.}

\item{\code{survival_selector}}{(\code{Selector})\cr
Survival selection operation to use in \code{\link[=mies_survival_plus]{mies_survival_plus()}} or \code{\link[=mies_survival_comma]{mies_survival_comma()}} (depending on the \code{survival_strategy} hyperparameter),
see there for more information. Default is \code{\link{SelectorProxy}}, which exposes the operation as a hyperparameter of the optimizer itself.}

\item{\code{elite_selector}}{(\code{Selector} | \code{NULL})\cr
Elite selector used in \code{\link[=mies_survival_comma]{mies_survival_comma()}}, see there for more information. "Comma" selection is only available when this
argument is not \code{NULL}. Default \code{NULL}.}

\item{\code{multi_fidelity}}{(\code{logical(1)})\cr
Whether to enable multi-fidelity optimization. When this is \code{TRUE}, then the \code{\link[bbotk:OptimInstance]{OptimInstance}} being optimized must
contain a \code{\link[paradox:Param]{Param}} tagged \code{"budget"}, which is then used as the "budget" search space component, determined by
\code{fidelity_schedule} instead of by the \code{\link{MiesOperator}}s themselves. For multi-fidelity optimization, the \code{fidelity_schedule},
\code{fidelity_generation_lookahead}, \code{fidelity_current_gen_only}, and \code{fidelity_monotonic} hyperparameters must be given to determine
multi-fidelity behaviour. (While the initial values for most of these are probably good for most cases in which more budget implies
higher fidelity, the \code{fidelity_schedule} hyperparameter should be adjusted in most cases). Default is \code{FALSE}.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-clone"></a>}}
\if{latex}{\out{\hypertarget{method-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{OptimizerMies$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
